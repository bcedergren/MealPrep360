name: Deploy to Production

on:
  push:
    branches: [main]
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (all, frontend, api-gateway, etc.)'
        required: false
        default: 'all'
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: 'false'

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECS_CLUSTER: mealprep360-cluster
  ENVIRONMENT: production

jobs:
  # Run tests before production deployment
  run-tests:
    name: Run Tests
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run API Gateway tests
        working-directory: ./MealPrep360-API
        run: |
          npm install
          npm test || true

      - name: Run Frontend tests
        working-directory: ./MealPrep360
        run: |
          npm install
          npm test || true

  # Build and push images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [run-tests]
    if: ${{ always() && (needs.run-tests.result == 'success' || github.event.inputs.skip_tests == 'true') }}
    permissions:
      id-token: write
      contents: read
    strategy:
      matrix:
        service:
          - name: frontend
            context: ./MealPrep360
          - name: admin
            context: ./MealPrep360-Admin
          - name: api-gateway
            context: ./MealPrep360-API
          - name: recipe-service
            context: ./MealPrep360-RecipeService
          - name: mealplan-service
            context: ./MealPrep360-MealPlanService
          - name: shopping-service
            context: ./MealPrep360-ShoppingListService
          - name: social-service
            context: ./MealPrep360-SocialMediaService
          - name: blog-service
            context: ./MealPrep360-BlogService
          - name: websocket-server
            context: ./MealPrep360-WebsocketServer

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/mealprep360/${{ matrix.service.name }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=prod-
            type=raw,value=production-latest
            type=raw,value=latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.context }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/mealprep360/${{ matrix.service.name }}:latest
          format: 'table'
          exit-code: '0'
          severity: 'CRITICAL,HIGH'

  # Deploy to production with approval
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    permissions:
      id-token: write
      contents: read
    environment:
      name: production
      url: https://mealprep360.com
    strategy:
      max-parallel: 2  # Deploy 2 services at a time to minimize downtime
      matrix:
        service:
          - name: frontend
          - name: admin
          - name: api-gateway
          - name: recipe-service
          - name: mealplan-service
          - name: shopping-service
          - name: social-service
          - name: blog-service
          - name: websocket-server

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS task definition
        id: task-def
        run: |
          # Get current task definition
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition mealprep360-${{ matrix.service.name }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' \
            --output json)
          
          # Update image in task definition
          NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq --arg IMAGE "${{ env.ECR_REGISTRY }}/mealprep360/${{ matrix.service.name }}:latest" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
          
          # Register new task definition
          NEW_TASK_ARN=$(echo $NEW_TASK_DEF | aws ecs register-task-definition \
            --cli-input-json file:///dev/stdin \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task-def-arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ matrix.service.name }} \
            --task-definition ${{ steps.task-def.outputs.task-def-arn }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ matrix.service.name }} \
            --region ${{ env.AWS_REGION }}

      - name: Verify deployment
        run: |
          # Check if service is running with the new task definition
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ matrix.service.name }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].runningCount' \
            --output text)
          
          if [ "$RUNNING_COUNT" -eq "0" ]; then
            echo "‚ùå No tasks running for ${{ matrix.service.name }}"
            exit 1
          else
            echo "‚úÖ ${{ matrix.service.name }} deployed successfully with $RUNNING_COUNT tasks"
          fi

  # Smoke tests after deployment
  smoke-tests:
    name: Post-Deployment Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-production]
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Test Frontend
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://mealprep360.com)
          if [ "$response" != "200" ]; then
            echo "‚ùå Frontend health check failed with status: $response"
            exit 1
          fi
          echo "‚úÖ Frontend is healthy"

      - name: Test API Gateway
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://api.mealprep360.com/api/health)
          if [ "$response" != "200" ]; then
            echo "‚ùå API Gateway health check failed with status: $response"
            exit 1
          fi
          echo "‚úÖ API Gateway is healthy"

      - name: Test Admin Panel
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://admin.mealprep360.com)
          if [ "$response" != "200" ]; then
            echo "‚ùå Admin Panel health check failed with status: $response"
            exit 1
          fi
          echo "‚úÖ Admin Panel is healthy"

  # Rollback on failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: failure()
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rollback all services
        run: |
          for service in frontend admin api-gateway recipe-service mealplan-service shopping-service social-service blog-service websocket-server; do
            echo "Rolling back $service..."
            aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service $service \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
          done

      - name: Notify rollback
        run: |
          echo "üîÑ Production deployment failed. Rollback initiated."
          # Add notification logic here

  # Notify deployment status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: always()
    steps:
      - name: Notify success
        if: ${{ needs.smoke-tests.result == 'success' }}
        run: |
          echo "‚úÖ Production deployment successful!"
          echo "üöÄ All services are running and healthy"
          # Add Slack/Discord/Email notification here

      - name: Notify failure
        if: ${{ needs.smoke-tests.result == 'failure' }}
        run: |
          echo "‚ùå Production deployment failed!"
          echo "üîÑ Rollback has been initiated"
          # Add Slack/Discord/Email notification here

